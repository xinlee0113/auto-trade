# 代码开发最佳实践规范

## 🚨 **核心原则**

### 1. **严格分层架构一致性原则 (Strict Layered Architecture Consistency)**
- **强制要求**：所有代码实现必须与架构设计图100%一致
- **强制要求**：类名、方法名、包结构必须与类图设计完全匹配
- **强制要求**：依赖关系必须严格遵循**向下单向依赖**原则
- **绝对禁止**：向上依赖、跨层依赖、同层循环依赖
- **绝对禁止**：未经架构设计更新就修改类结构或添加依赖
- **必须做**：任何架构变更必须先更新设计图，再修改代码
- **必须做**：新增类必须放在正确的架构层级目录中

### 2. **唯一可信原则 (Single Source of Truth)**
- **绝对禁止**：为同一功能创建多个文件
- **绝对禁止**：创建带有后缀的文件 (如 `_optimized`, `_improved`, `_final`, `_v2`)
- **必须做**：修改现有文件而非创建新文件
- **必须做**：删除旧文件后再创建新文件

### 3. **先分析后编码原则 (Think Before Code)**
```
开发流程：
1. 🔍 分析需求 → 明确功能目标
2. 📐 检查架构设计 → 确认类图和结构图
3. 📂 确定代码归属 → 严格按照架构层级放置
4. 🏗️ 选择正确位置 → 现有文件 vs 新建文件
5. ✍️ 编写代码 → 遵循架构设计和SOLID原则
6. 🧪 测试验证 → 确保功能正确
7. 📋 架构一致性检查 → 验证是否符合设计
```

## 🏗️ **架构设计原则**

### **SOLID原则严格遵守**

#### S - 单一职责原则 (Single Responsibility)
- **一个类/模块只负责一个功能领域**
- **示例**：
  ```
  ✅ 正确：GreeksCalculator 只负责Greeks计算
  ❌ 错误：GreeksCalculator 同时处理数据获取和风险管理
  ```

#### O - 开闭原则 (Open/Closed)
- **对扩展开放，对修改封闭**
- **示例**：
  ```
  ✅ 正确：通过策略模式扩展新的期权筛选算法
  ❌ 错误：直接修改现有筛选逻辑破坏原有功能
  ```

#### L - 里氏替换原则 (Liskov Substitution)
- **子类必须能够替换父类**
- **示例**：
  ```
  ✅ 正确：RealTimeDataManager 可以替换 DataManager
  ❌ 错误：MockDataManager 需要额外的配置才能工作
  ```

#### I - 接口隔离原则 (Interface Segregation)
- **不要强迫客户端依赖不需要的接口**
- **示例**：
  ```
  ✅ 正确：MarketDataReader, MarketDataWriter 分离
  ❌ 错误：一个巨大的 MarketDataInterface 包含所有方法
  ```

#### D - 依赖倒置原则 (Dependency Inversion)
- **高层模块不依赖低层模块，都依赖抽象**
- **示例**：
  ```
  ✅ 正确：TradingEngine 依赖 DataProvider 接口
  ❌ 错误：TradingEngine 直接依赖 TigerAPIClient
  ```

## 📁 **项目架构标准**

### **文件组织结构**
```
src/
├── api/                    # 外部API接口层
│   └── broker_tiger_api.py    # Tiger证券API封装 (唯一)
├── config/                 # 配置管理层
│   ├── trading_config.py       # 交易配置 (唯一)
│   └── option_config.py        # 期权配置 (唯一)
├── data/                   # 数据管理层
│   └── realtime_data_manager.py # 实时数据管理器 (唯一)
├── models/                 # 数据模型层
│   ├── trading_models.py       # 交易模型 (唯一)
│   └── option_models.py        # 期权模型 (唯一)
├── services/               # 业务服务层
│   ├── market_analyzer.py      # 市场分析器 (唯一)
│   ├── option_analyzer.py      # 期权分析器 (唯一)
│   └── risk_manager.py         # 风险管理器 (唯一)
└── utils/                  # 工具函数层
    ├── greeks_calculator.py    # Greeks计算器 (唯一)
    ├── technical_indicators.py # 技术指标 (唯一)
    ├── parallel_api_manager.py # API并行管理器 (唯一)
    └── ...                     # 其他工具类
```

### **文件职责矩阵**
| 层级 | 职责 | 禁止内容 |
|------|------|----------|
| **api/** | 外部API封装，数据格式转换 | 业务逻辑，计算逻辑 |
| **config/** | 配置参数，常量定义 | 数据处理，算法实现 |
| **data/** | 数据获取，数据缓存，数据流管理 | 业务决策，交易逻辑 |
| **models/** | 数据结构定义，数据验证 | 业务处理，计算逻辑 |
| **services/** | 核心业务逻辑，策略实现 | 数据获取，UI交互 |
| **utils/** | 纯函数，工具类，计算引擎 | 状态管理，业务决策 |

## 🚦 **开发决策流程**

### **新增代码时的决策树**
```
需要写代码时：
├─ 🔍 这个功能已经存在吗？
│  ├─ ✅ 是 → 直接修改现有文件
│  └─ ❌ 否 → 继续分析
├─ 📂 这个功能属于哪个层级？
│  ├─ API调用 → src/api/
│  ├─ 配置管理 → src/config/
│  ├─ 数据处理 → src/data/
│  ├─ 数据模型 → src/models/
│  ├─ 业务逻辑 → src/services/
│  └─ 工具函数 → src/utils/
├─ 🏗️ 该层级下是否有合适的现有文件？
│  ├─ ✅ 有 → 扩展现有文件
│  └─ ❌ 无 → 创建新文件 (慎重!)
└─ ⚖️ 新文件是否符合单一职责？
   ├─ ✅ 是 → 可以创建
   └─ ❌ 否 → 重新设计架构
```

### **修改vs新建的判断标准**
| 场景 | 操作 | 理由 |
|------|------|------|
| 功能增强/优化 | ✅ 修改现有文件 | 避免重复，保持唯一性 |
| Bug修复 | ✅ 修改现有文件 | 保持代码一致性 |
| 新增方法到现有类 | ✅ 修改现有文件 | 符合面向对象原则 |
| 全新功能领域 | ⚠️ 新建文件 (慎重) | 确保符合单一职责 |
| 临时测试/验证 | ❌ 禁止 | 使用现有demo或测试文件 |

## 📝 **命名规范**

### **文件命名**
```
模式：{功能域}_{类型}.py
示例：
- trading_config.py        # 交易配置
- market_analyzer.py       # 市场分析器
- greeks_calculator.py     # Greeks计算器

禁止：
- xxx_v2.py               # 版本后缀
- xxx_improved.py         # 改进后缀
- xxx_final.py            # 最终后缀
- xxx_optimized.py        # 优化后缀
```

### **类和函数命名**
```
类名：PascalCase
函数名：snake_case
常量：UPPER_SNAKE_CASE
私有方法：_method_name
```

## 🧪 **代码质量标准**

### **每个文件必须包含**
1. **文档字符串** - 说明文件用途和功能
2. **类型注解** - 所有函数参数和返回值
3. **错误处理** - 适当的异常处理机制
4. **日志记录** - 关键操作的日志
5. **测试覆盖** - 对应的测试文件

### **代码审查检查项**
- [ ] 是否违反唯一可信原则？
- [ ] 是否符合SOLID原则？
- [ ] 职责是否单一明确？
- [ ] 是否有重复代码？
- [ ] 是否有正确的错误处理？
- [ ] 是否有充分的测试覆盖？

## 🚨 **严格禁止的行为**

### **文件创建禁令**
```
❌ 绝对禁止的文件名模式：
- *_v2.py, *_v3.py
- *_improved.py, *_enhanced.py
- *_optimized.py, *_advanced.py
- *_final.py, *_new.py
- *_fixed.py, *_corrected.py
- *_backup.py, *_old.py
- demo_*.py (在项目根目录下创建临时demo)
- test_*.py (在项目根目录下创建临时测试)
```

### **代码重复禁令**
```
❌ 禁止重复实现：
- 相同的计算逻辑
- 相似的数据获取方法
- 重复的配置管理
- 相同的错误处理模式
```

## 🔧 **重构指导原则**

### **何时重构现有文件**
1. **功能扩展** - 在现有文件基础上增加新方法
2. **性能优化** - 改进现有算法，保持接口不变
3. **Bug修复** - 修正错误逻辑，不改变公共接口
4. **代码清理** - 提高可读性，移除冗余代码

### **何时拆分文件**
1. **文件过大** - 超过500行且职责混乱
2. **职责不单一** - 一个文件处理多个不相关的功能
3. **依赖过多** - 导入了过多不相关的模块
4. **测试困难** - 无法进行有效的单元测试

## 📋 **开发检查清单**

### **编码前检查**
- [ ] 我清楚这个功能的具体需求吗？
- [ ] 我检查过现有代码结构了吗？
- [ ] 我确定了代码应该放在哪个文件吗？
- [ ] 我确认没有重复功能吗？

### **编码中检查**
- [ ] 我的代码职责单一吗？
- [ ] 我的代码符合SOLID原则吗？
- [ ] 我的命名是否清晰明确？
- [ ] 我的代码是否有适当的注释？

### **编码后检查**
- [ ] 我的代码与架构设计图100%一致吗？
- [ ] 我的类名与类图设计完全匹配吗？
- [ ] 我的依赖关系遵循分层架构吗？
- [ ] 我的代码通过所有测试了吗？
- [ ] 我删除了临时/调试代码吗？
- [ ] 我更新了相关文档吗？
- [ ] 我确认没有创建重复文件吗？

---

## 💡 **成功案例参考**

### **正确的功能扩展示例**
```python
# ✅ 正确：在现有文件中扩展功能
# src/utils/greeks_calculator.py

class GreeksCalculator:
    def calculate_delta(self, ...):
        # 原有功能
    
    def calculate_gamma(self, ...):
        # 原有功能
    
    def calculate_charm(self, ...):  # 新增功能
        # 新增的Greeks计算
```

### **正确的架构分离示例**
```python
# ✅ 正确：职责明确分离
# src/services/market_analyzer.py - 负责市场分析
# src/data/realtime_data_manager.py - 负责数据管理
# src/utils/parallel_api_manager.py - 负责API并行调用
```

---

**🎯 记住：编码前先思考，修改胜过新建，质量重于数量！**
